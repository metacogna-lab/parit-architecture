{
  "version": 3,
  "sources": ["../../../packages/shared/src/systemPrompts.ts", "../src/systemPrompts.ts", "../src/context.ts", "../src/utils.ts", "../src/stream.ts", "../src/index.ts"],
  "sourceRoot": "dist",
  "sourcesContent": ["\n// --- JSON Enforcement ---\nexport const RESPONSE_FORMAT_INSTRUCTION = `\nCRITICAL: You must respond ONLY in the following valid JSON format. Do not add markdown blocks like \\`\\`\\`json.\n{\n  \"system_state\": {\n    \"current_phase\": \"<CURRENT_PHASE_NAME>\",\n    \"status\": \"complete\" | \"interrupted\", \n    \"interrupt_signal\": boolean, // Set true if human review is strictly needed (e.g. Data/Logic phases)\n    \"message\": \"Short status message\"\n  },\n  \"artifact\": {\n    \"type\": \"code\" | \"markdown\" | \"mermaid_erd\",\n    \"content\": \"<The actual content string, properly escaped>\",\n    \"logic_summary\": \"Short summary of work\"\n  },\n  \"trace\": {\n    \"agent\": \"<Your Agent Name>\",\n    \"reasoning\": \"Brief explanation of your decisions\",\n    \"tokens_estimated\": <estimated_integer>\n  }\n}\n`;\n\n// --- Supervisor Agent ---\nexport const SUPERVISOR_PROMPT = `You are the Supervisor of a software architecture team.\nYour goal is to orchestrate the following workers to build a complete system specification:\n1. Logic Worker (defines business rules, user stories)\n2. Design Worker (defines UI tokens, component specs)\n3. Validator (checks for consistency and errors)\n\nGiven a user request or a stage in the pipeline, decide which worker should act next.\nIf a stage is complete and valid, output \"FINISH\".\nIf you need human approval before moving to a critical phase (Data Modeling or API Specs), output \"INTERRUPT\".\n${RESPONSE_FORMAT_INSTRUCTION}\n`;\n\n// --- PRD Worker ---\nexport const PRD_WORKER_PROMPT = `You are a Lead Product Manager and Innovation Strategist.\nYour goal is to transform a basic product concept into a comprehensive, professional Product Requirements Document (PRD).\n\n### Instructions:\n1.  **Analyze & Enrich**: Take the user's input (Product Seed) and expand upon it. Infer implicit needs, standard features for this domain, and potential \"delighters\".\n2.  **Structure**: The 'artifact.content' MUST be valid Markdown using the following structure:\n    *   **# [Product Name] - PRD**\n    *   **## 1. Executive Summary**: A high-level pitch of the vision, problem solved, and target audience.\n    *   **## 2. User Personas**: Define 2-3 distinct personas (Name, Role, Key Goals, Pain Points).\n    *   **## 3. Functional Requirements**: Detailed list of features. Group them logically (e.g., Auth, Core Workflow, Settings).\n    *   **## 4. Non-Functional Requirements**: Standards for Performance, Security, Scalability, and Accessibility (WCAG).\n    *   **## 5. Roadmap (MoSCoW)**:\n        *   **Must Have**: Critical path for MVP.\n        *   **Should Have**: High priority, not blocking launch.\n        *   **Could Have**: Nice to have.\n        *   **Won't Have**: Out of scope for V1.\n\n### Response Constraints:\n- Use professional, definitive, and clear language.\n- Ensure the 'system_state.current_phase' is 'PRD'.\n- Ensure the 'artifact.type' is 'markdown'.\n\n${RESPONSE_FORMAT_INSTRUCTION}\n`;\n\n// --- Data Worker ---\nexport const DATA_WORKER_PROMPT = `You are a Database Architect. Ensure 3NF normalization. Group entities by module.\n      \nCRITICAL: Your artifact.content MUST be a JSON string array of SchemaTable objects matching this structure:\n[{\n  \"name\": \"TableName\",\n  \"module\": \"ModuleName\",\n  \"description\": \"Description\",\n  \"fields\": [{ \"name\": \"id\", \"type\": \"uuid\", \"required\": true, \"isKey\": true, \"description\": \"PK\" }]\n}]\n\nDo not wrap the JSON in markdown code blocks inside the string. Just valid JSON string.\n\n${RESPONSE_FORMAT_INSTRUCTION}`;\n", "import { RESPONSE_FORMAT_INSTRUCTION } from '@parit/shared';\n\nexport const SUPERVISOR_PROMPT = `You are the Supervisor of a software architecture team.\nYour goal is to orchestrate the following workers to build a complete system specification:\n1. Logic Worker (defines business rules, user stories)\n2. Design Worker (defines UI tokens, component specs)\n3. Validator (checks for consistency and errors)\n\nGiven a user request or a stage in the pipeline, decide which worker should act next.\nIf a stage is complete and valid, output \"FINISH\".\nIf you need human approval before moving to a critical phase (Data Modeling or API Specs), output \"INTERRUPT\".\n${RESPONSE_FORMAT_INSTRUCTION}\n`;", "\nimport { Env } from './index';\n\nexport async function assembleContext(env: Env, projectId: string): Promise<string> {\n  if (!env.DB) {\n      console.warn(\"DB binding not found during context assembly.\");\n      return \"\";\n  }\n\n  try {\n      // 1. Get Seed from D1\n      const project = await env.DB.prepare(\"SELECT product_seed FROM projects WHERE id = ?\").bind(projectId).first<{product_seed: string}>();\n      if (!project) return \"\";\n\n      // 2. Get Artifacts from D1 (simpler than R2 for metadata) to build context\n      // Fetch summary of recent artifacts\n      const artifacts = await env.DB.prepare(\"SELECT agent_id, content FROM artifacts WHERE project_id = ? ORDER BY created_at ASC\").bind(projectId).all<{agent_id: string, content: string}>();\n      \n      let context = `Project Goal: ${project.product_seed}\\n\\nExisting Architecture:\\n`;\n      if (artifacts.results) {\n          artifacts.results.forEach(a => {\n              // Truncate content to avoid blowing up context window, assuming content is string\n              // If content is R2 key, we might need to skip or fetch, but usually artifacts table holds metadata or small content\n              // For this implementation, we assume it might contain text.\n              const contentPreview = a.content.length > 500 ? a.content.substring(0, 500) + \"...\" : a.content;\n              context += `[${a.agent_id.toUpperCase()}]: ${contentPreview}\\n`;\n          });\n      }\n      \n      return context;\n  } catch (e) {\n      console.error(\"Context assembly failed\", e);\n      return \"\";\n  }\n}\n", "/**\n * Utility functions for Parit Supervisor Worker\n */\n\n/**\n * Generate a UUID v4\n * Uses crypto.randomUUID() which is available in Cloudflare Workers\n */\nexport function generateUUID(): string {\n  return crypto.randomUUID();\n}\n\n/**\n * Get current timestamp in milliseconds (Unix epoch)\n */\nexport function now(): number {\n  return Date.now();\n}\n\n/**\n * Validate UUID format\n */\nexport function isValidUUID(uuid: string): boolean {\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n  return uuidRegex.test(uuid);\n}\n\n/**\n * Standardized error response\n */\nexport interface ErrorResponse {\n  success: false;\n  error: {\n    code: string;\n    message: string;\n    details?: any;\n  };\n}\n\n/**\n * Standardized success response\n */\nexport interface SuccessResponse<T = any> {\n  success: true;\n  data: T;\n}\n\n/**\n * Create error response\n */\nexport function errorResponse(\n  code: string,\n  message: string,\n  status: number = 500,\n  details?: any,\n  corsHeaders: Record<string, string> = {}\n): Response {\n  const payload: ErrorResponse = {\n    success: false,\n    error: { code, message, details }\n  };\n\n  return new Response(JSON.stringify(payload), {\n    status,\n    headers: {\n      ...corsHeaders,\n      'Content-Type': 'application/json'\n    }\n  });\n}\n\n/**\n * Create success response\n */\nexport function successResponse<T>(\n  data: T,\n  status: number = 200,\n  corsHeaders: Record<string, string> = {}\n): Response {\n  const payload: SuccessResponse<T> = {\n    success: true,\n    data\n  };\n\n  return new Response(JSON.stringify(payload), {\n    status,\n    headers: {\n      ...corsHeaders,\n      'Content-Type': 'application/json'\n    }\n  });\n}\n\n/**\n * Parse and validate request JSON body\n */\nexport async function parseRequestBody<T>(request: Request): Promise<T> {\n  try {\n    return await request.json() as T;\n  } catch (e) {\n    throw new Error('Invalid JSON in request body');\n  }\n}\n\n/**\n * Sanitize project name\n */\nexport function sanitizeProjectName(name: string): string {\n  // Trim whitespace and limit length\n  return name.trim().substring(0, 255);\n}\n\n/**\n * Sanitize product seed\n */\nexport function sanitizeProductSeed(seed: string): string {\n  // Trim whitespace and limit length to 10KB\n  return seed.trim().substring(0, 10000);\n}\n\n/**\n * Check if stage requires HITL interrupt\n */\nexport function requiresInterrupt(stage: string): boolean {\n  const INTERRUPT_STAGES = ['data', 'logic'];\n  return INTERRUPT_STAGES.includes(stage);\n}\n\n/**\n * Estimate artifact size in bytes\n */\nexport function estimateSize(content: string): number {\n  // Rough estimate: each character = 1 byte (ASCII) or up to 4 bytes (UTF-8)\n  return new Blob([content]).size;\n}\n\n/**\n * Should artifact be stored in R2?\n */\nexport function shouldUseR2(content: string): boolean {\n  const SIZE_THRESHOLD = 100 * 1024; // 100KB\n  return estimateSize(content) >= SIZE_THRESHOLD;\n}\n", "\nimport { Env } from './index';\nimport { assembleContext } from './context';\nimport { requiresInterrupt } from './utils';\n\nexport function createAgentStream() {\n  const { readable, writable } = new TransformStream();\n  const writer = writable.getWriter();\n  const encoder = new TextEncoder();\n\n  const streamUpdate = async (type: string, data: any) => {\n    const msg = `data: ${JSON.stringify({ type, ...data })}\\n\\n`;\n    await writer.write(encoder.encode(msg));\n  };\n\n  return {\n    readable,\n    streamUpdate,\n    close: () => writer.close()\n  };\n}\n\nexport async function handleStreamRequest(request: Request, env: Env) {\n  const { readable, writable } = new TransformStream();\n  const writer = writable.getWriter();\n  const encoder = new TextEncoder();\n\n  // Extract Payload\n  let body: any = {};\n  try {\n      body = await request.json();\n  } catch (e) {\n      console.warn(\"Failed to parse request body for stream context injection\");\n  }\n\n  const projectId = request.headers.get('X-Project-ID') || body.projectId;\n  \n  // Context Assembly\n  let injectedContext = \"\";\n  if (projectId) {\n      injectedContext = await assembleContext(env, projectId);\n  }\n\n  // 1. Kick off parallel execution\n  const agentTasks = [];\n  if (env.PRD_AGENT) agentTasks.push({ id: 'prd', binding: env.PRD_AGENT });\n  if (env.DATA_AGENT) agentTasks.push({ id: 'data', binding: env.DATA_AGENT });\n  if (env.LOGIC_AGENT) agentTasks.push({ id: 'logic', binding: env.LOGIC_AGENT });\n\n  // 2. Stream Heartbeats & Partial Data\n  const streamPromises = agentTasks.map(async (agent) => {\n    try {\n        // Construct new body with injected context\n        const agentBody = {\n            ...body,\n            context: (body.context || \"\") + \"\\n\\n\" + injectedContext\n        };\n\n        const agentReq = new Request(request.url, {\n            method: request.method,\n            headers: new Headers(request.headers),\n            body: JSON.stringify(agentBody)\n        });\n        \n        agentReq.headers.set(\"X-Target-Agent\", agent.id);\n        agentReq.headers.set(\"Accept\", \"text/event-stream\");\n        agentReq.headers.set(\"Content-Type\", \"application/json\");\n\n        const response = await agent.binding.fetch(agentReq);\n        const reader = response.body?.getReader();\n\n        if (!reader) return;\n\n        const decoder = new TextDecoder();\n        while (true) {\n            const { value, done } = await reader.read();\n            if (done) break;\n\n            const chunk = decoder.decode(value, { stream: true });\n            const lines = chunk.split('\\n');\n            \n            for (const line of lines) {\n                if (line.trim().startsWith('data: ')) {\n                    try {\n                        const json = JSON.parse(line.substring(6));\n                        \n                        let status: 'thinking' | 'writing' | 'complete' = 'thinking';\n                        let delta = '';\n\n                        if (json.type === 'delta') {\n                            status = 'writing';\n                            delta = json.content || '';\n                        } else if (json.type === 'status') {\n                            status = 'thinking';\n                            delta = json.message || '';\n                        } else if (json.type === 'complete') {\n                            status = 'complete';\n                            delta = json.message || 'Done';\n\n                            // \u2705 HITL Interrupt Detection\n                            // Check if this agent requires interrupt AND returned interrupt_signal\n                            if (json.response && requiresInterrupt(agent.id)) {\n                                const agentResponse = json.response;\n\n                                if (agentResponse.system_state?.interrupt_signal === true) {\n                                    // Send interrupt event to frontend\n                                    const interruptPacket = {\n                                        timestamp: Date.now(),\n                                        agentId: agent.id,\n                                        delta: '\u26A0\uFE0F Human review required',\n                                        status: 'interrupted' as const,\n                                        interrupt: {\n                                            stage: agent.id,\n                                            artifact: agentResponse.artifact,\n                                            message: agentResponse.system_state.message,\n                                            reasoning: agentResponse.trace?.reasoning || ''\n                                        }\n                                    };\n\n                                    const interruptSSE = `data: ${JSON.stringify(interruptPacket)}\\n\\n`;\n                                    await writer.write(encoder.encode(interruptSSE));\n\n                                    // Log interrupt for observability\n                                    console.log(`[SUPERVISOR] HITL interrupt triggered for ${agent.id}`);\n\n                                    // Don't send normal complete packet if interrupted\n                                    continue;\n                                }\n                            }\n                        } else if (json.type === 'error') {\n                            status = 'complete';\n                            delta = `Error: ${json.chunk || json.message}`;\n                        }\n\n                        const packet = {\n                            timestamp: Date.now(),\n                            agentId: agent.id,\n                            delta: delta,\n                            status: status\n                        };\n\n                        const sse = `data: ${JSON.stringify(packet)}\\n\\n`;\n                        await writer.write(encoder.encode(sse));\n                    } catch (e) {\n                         // ignore parse errors\n                    }\n                }\n            }\n        }\n    } catch (e) {\n        const errPacket = {\n            timestamp: Date.now(),\n            agentId: agent.id,\n            delta: String(e),\n            status: 'complete'\n        };\n        const err = `data: ${JSON.stringify(errPacket)}\\n\\n`;\n        await writer.write(encoder.encode(err));\n    }\n  });\n\n  // 3. Close stream when all agents finish\n  Promise.allSettled(streamPromises).then(() => {\n      writer.close();\n  });\n\n  return new Response(readable, {\n    headers: {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      \"Connection\": \"keep-alive\",\n      \"X-Accel-Buffering\": \"no\"\n    }\n  });\n}\n", "\nimport { SUPERVISOR_PROMPT } from './systemPrompts';\nimport { handleStreamRequest } from './stream';\nimport { ArchitectureState } from '@parit/shared';\nimport {\n  generateUUID,\n  now,\n  isValidUUID,\n  errorResponse,\n  successResponse,\n  parseRequestBody,\n  sanitizeProjectName,\n  sanitizeProductSeed,\n  requiresInterrupt,\n  shouldUseR2\n} from './utils';\n\ninterface Fetcher {\n  fetch(input: Request | string, init?: RequestInit): Promise<Response>;\n}\n\n// D1 Database Binding Interface\ninterface D1Result<T = unknown> {\n  results: T[];\n  success: boolean;\n  error?: string;\n  meta: any;\n}\n\ninterface D1PreparedStatement {\n  bind(...values: any[]): D1PreparedStatement;\n  first<T = unknown>(colName?: string): Promise<T | null>;\n  run<T = unknown>(): Promise<D1Result<T>>;\n  all<T = unknown>(): Promise<D1Result<T>>;\n}\n\ninterface D1Database {\n  prepare(query: string): D1PreparedStatement;\n  dump(): Promise<ArrayBuffer>;\n  batch(statements: D1PreparedStatement[]): Promise<D1Result[]>;\n  exec(query: string): Promise<D1Result>;\n}\n\n// R2 Bucket Binding Interface\ninterface R2Bucket {\n  get(key: string): Promise<any>;\n  put(key: string, value: any, options?: any): Promise<any>;\n}\n\ninterface ExecutionContext {\n  waitUntil(promise: Promise<any>): void;\n  passThroughOnException(): void;\n}\n\nexport interface Env {\n  PRD_AGENT: Fetcher;\n  DATA_AGENT: Fetcher;\n  LOGIC_AGENT: Fetcher;\n  AGENT_ROLE: string;\n  DB: D1Database;\n  STORAGE: R2Bucket;\n}\n\nexport default {\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n    const url = new URL(request.url);\n    const method = request.method;\n    const isStream = request.headers.get('Accept') === 'text/event-stream';\n    const target = request.headers.get('X-Target-Agent') || url.searchParams.get('agent');\n\n    // CORS Headers\n    const corsHeaders = {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n      \"Access-Control-Allow-Headers\": \"Content-Type, X-Agent-Provider, X-Agent-Type, X-Cloud-Trace-Context, X-Project-Env, Accept, X-Project-ID, X-Google-Key, X-OpenAI-Key\",\n    };\n\n    if (method === \"OPTIONS\") {\n      return new Response(null, { headers: corsHeaders });\n    }\n\n    // --- READ ENDPOINTS (Hydration) ---\n\n    // 1. List Projects\n    // GET /api/projects\n    if (method === 'GET' && url.pathname === '/api/projects') {\n      try {\n        const { results } = await env.DB.prepare(\n          \"SELECT * FROM projects ORDER BY updated_at DESC LIMIT 50\"\n        ).run();\n        return new Response(JSON.stringify(results), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });\n      } catch (e) {\n        return new Response(JSON.stringify({ error: String(e) }), { status: 500, headers: corsHeaders });\n      }\n    }\n\n    // 2. Master Hydration Endpoint\n    // GET /api/hydrate/:projectId\n    if (method === 'GET' && url.pathname.startsWith('/api/hydrate/')) {\n      const projectId = url.pathname.split('/').pop();\n      if (!projectId) return new Response(\"Missing Project ID\", { status: 400, headers: corsHeaders });\n\n      try {\n        // Parallel Fetching for Performance\n        const [projectRes, logsRes, artifactsRes, checkpointsRes] = await Promise.all([\n          env.DB.prepare(\"SELECT * FROM projects WHERE id = ?\").bind(projectId).first(),\n          env.DB.prepare(\"SELECT * FROM execution_traces WHERE project_id = ? ORDER BY created_at DESC LIMIT 100\").bind(projectId).run(),\n          env.DB.prepare(\"SELECT * FROM artifacts WHERE project_id = ? ORDER BY created_at DESC\").bind(projectId).run(),\n          env.DB.prepare(\"SELECT * FROM checkpoints WHERE project_id = ? ORDER BY created_at DESC LIMIT 20\").bind(projectId).run()\n        ]);\n\n        if (!projectRes) {\n          return new Response(\"Project Not Found\", { status: 404, headers: corsHeaders });\n        }\n\n        const responsePayload = {\n          project: projectRes,\n          history: {\n            logs: logsRes.results || [],\n            artifacts: artifactsRes.results || [],\n            checkpoints: checkpointsRes.results || []\n          }\n        };\n\n        return new Response(JSON.stringify(responsePayload), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });\n\n      } catch (e) {\n        return new Response(JSON.stringify({ error: String(e) }), { status: 500, headers: corsHeaders });\n      }\n    }\n    \n    // 3. Artifact Content Proxy (R2)\n    // GET /api/artifacts/:key\n    if (method === 'GET' && url.pathname.startsWith('/api/artifacts/content/')) {\n        // URL Decode the key passed in the path\n        const key = decodeURIComponent(url.pathname.replace('/api/artifacts/content/', ''));\n        try {\n            const object = await env.STORAGE.get(key);\n            if (!object) return new Response(\"Artifact Not Found\", { status: 404, headers: corsHeaders });\n\n            const headers = new Headers();\n            object.writeHttpMetadata(headers);\n            headers.set('etag', object.httpEtag);\n            headers.set('Access-Control-Allow-Origin', '*');\n\n            return new Response(object.body, { headers });\n        } catch (e) {\n            return new Response(JSON.stringify({ error: String(e) }), { status: 500, headers: corsHeaders });\n        }\n    }\n\n    // --- WRITE ENDPOINTS (Inference) ---\n\n    // 4. Create New Project (Server-Generated UUID)\n    // POST /api/projects\n    if (method === 'POST' && url.pathname === '/api/projects') {\n      try {\n        const body = await parseRequestBody<{\n          productSeed: string;\n          name?: string;\n          environment?: string;\n        }>(request);\n\n        // Validation\n        if (!body.productSeed || body.productSeed.trim().length === 0) {\n          return errorResponse('INVALID_REQUEST', 'Product seed is required', 400, null, corsHeaders);\n        }\n\n        // Generate server-side UUID\n        const projectId = generateUUID();\n        const timestamp = now();\n        const projectName = body.name ? sanitizeProjectName(body.name) : 'Untitled Project';\n        const productSeed = sanitizeProductSeed(body.productSeed);\n        const environment = body.environment || 'development';\n\n        // Insert into D1\n        const result = await env.DB.prepare(`\n          INSERT INTO projects (id, name, product_seed, environment, created_at, updated_at)\n          VALUES (?, ?, ?, ?, ?, ?)\n        `).bind(projectId, projectName, productSeed, environment, timestamp, timestamp).run();\n\n        if (!result.success) {\n          return errorResponse('DATABASE_ERROR', 'Failed to create project', 500, result.error, corsHeaders);\n        }\n\n        // Return project data\n        return successResponse({\n          projectId,\n          name: projectName,\n          productSeed,\n          environment,\n          createdAt: timestamp,\n          updatedAt: timestamp\n        }, 201, corsHeaders);\n\n      } catch (e: any) {\n        return errorResponse('INTERNAL_ERROR', e.message || 'Failed to create project', 500, null, corsHeaders);\n      }\n    }\n\n    // 5. Save Checkpoint (Time Travel)\n    // POST /api/checkpoints\n    if (method === 'POST' && url.pathname === '/api/checkpoints') {\n      try {\n        const body = await parseRequestBody<{\n          projectId: string;\n          phase: string;\n          stateSnapshot: any; // Will be stringified\n          agentId?: string;\n          isInterrupted?: boolean;\n        }>(request);\n\n        // Validation\n        if (!body.projectId || !isValidUUID(body.projectId)) {\n          return errorResponse('INVALID_REQUEST', 'Valid project ID is required', 400, null, corsHeaders);\n        }\n\n        if (!body.phase) {\n          return errorResponse('INVALID_REQUEST', 'Phase is required', 400, null, corsHeaders);\n        }\n\n        const checkpointId = generateUUID();\n        const timestamp = now();\n        const stateJson = JSON.stringify(body.stateSnapshot);\n\n        // Insert checkpoint\n        const result = await env.DB.prepare(`\n          INSERT INTO checkpoints (checkpoint_id, project_id, phase, state_snapshot, agent_id, is_interrupted, created_at)\n          VALUES (?, ?, ?, ?, ?, ?, ?)\n        `).bind(\n          checkpointId,\n          body.projectId,\n          body.phase,\n          stateJson,\n          body.agentId || null,\n          body.isInterrupted ? 1 : 0,\n          timestamp\n        ).run();\n\n        if (!result.success) {\n          return errorResponse('DATABASE_ERROR', 'Failed to save checkpoint', 500, result.error, corsHeaders);\n        }\n\n        return successResponse({\n          checkpointId,\n          projectId: body.projectId,\n          phase: body.phase,\n          createdAt: timestamp\n        }, 201, corsHeaders);\n\n      } catch (e: any) {\n        return errorResponse('INTERNAL_ERROR', e.message || 'Failed to save checkpoint', 500, null, corsHeaders);\n      }\n    }\n\n    // 6. Restore from Checkpoint (Time Travel)\n    // POST /api/restore\n    if (method === 'POST' && url.pathname === '/api/restore') {\n      try {\n        const body = await parseRequestBody<{\n          projectId: string;\n          checkpointId: string;\n        }>(request);\n\n        // Validation\n        if (!body.projectId || !isValidUUID(body.projectId)) {\n          return errorResponse('INVALID_REQUEST', 'Valid project ID is required', 400, null, corsHeaders);\n        }\n\n        if (!body.checkpointId || !isValidUUID(body.checkpointId)) {\n          return errorResponse('INVALID_REQUEST', 'Valid checkpoint ID is required', 400, null, corsHeaders);\n        }\n\n        // Fetch checkpoint\n        const checkpoint = await env.DB.prepare(`\n          SELECT * FROM checkpoints WHERE checkpoint_id = ? AND project_id = ?\n        `).bind(body.checkpointId, body.projectId).first();\n\n        if (!checkpoint) {\n          return errorResponse('NOT_FOUND', 'Checkpoint not found', 404, null, corsHeaders);\n        }\n\n        // Parse state snapshot\n        let stateSnapshot;\n        try {\n          stateSnapshot = JSON.parse(checkpoint.state_snapshot as string);\n        } catch (e) {\n          return errorResponse('INTERNAL_ERROR', 'Invalid checkpoint data', 500, null, corsHeaders);\n        }\n\n        // Delete future checkpoints (time travel truncates future)\n        await env.DB.prepare(`\n          DELETE FROM checkpoints\n          WHERE project_id = ? AND created_at > ?\n        `).bind(body.projectId, checkpoint.created_at).run();\n\n        // Return restored state\n        return successResponse({\n          projectId: body.projectId,\n          checkpointId: body.checkpointId,\n          phase: checkpoint.phase,\n          stateSnapshot,\n          restoredAt: now()\n        }, 200, corsHeaders);\n\n      } catch (e: any) {\n        return errorResponse('INTERNAL_ERROR', e.message || 'Failed to restore checkpoint', 500, null, corsHeaders);\n      }\n    }\n\n    // 7. Resume from HITL Interrupt\n    // POST /api/resume\n    if (method === 'POST' && url.pathname === '/api/resume') {\n      try {\n        const body = await parseRequestBody<{\n          projectId: string;\n          stage: string;\n          action: 'approve' | 'reject' | 'edit';\n          feedback?: string;\n          editedArtifact?: string;\n        }>(request);\n\n        // Validation\n        if (!body.projectId || !isValidUUID(body.projectId)) {\n          return errorResponse('INVALID_REQUEST', 'Valid project ID is required', 400, null, corsHeaders);\n        }\n\n        if (!body.stage) {\n          return errorResponse('INVALID_REQUEST', 'Stage is required', 400, null, corsHeaders);\n        }\n\n        if (!['approve', 'reject', 'edit'].includes(body.action)) {\n          return errorResponse('INVALID_REQUEST', 'Action must be approve, reject, or edit', 400, null, corsHeaders);\n        }\n\n        // Handle different actions\n        let targetStage = body.stage;\n        let shouldContinue = true;\n\n        if (body.action === 'approve') {\n          // Continue to next stage\n          shouldContinue = true;\n        } else if (body.action === 'reject') {\n          // Supervisor routing logic based on feedback\n          // For now, simple heuristic: re-execute current stage\n          // In production, this would analyze feedback and route intelligently\n          const feedback = body.feedback || '';\n\n          // Simple routing heuristic\n          if (feedback.toLowerCase().includes('requirement') || feedback.toLowerCase().includes('prd')) {\n            targetStage = 'prd';\n          } else if (feedback.toLowerCase().includes('design') || feedback.toLowerCase().includes('ui')) {\n            targetStage = 'design';\n          } else {\n            // Re-execute current stage\n            targetStage = body.stage;\n          }\n\n          shouldContinue = true;\n        } else if (body.action === 'edit') {\n          // User provided edited artifact, use it and continue\n          if (!body.editedArtifact) {\n            return errorResponse('INVALID_REQUEST', 'Edited artifact is required for edit action', 400, null, corsHeaders);\n          }\n\n          // Save edited artifact to D1\n          const artifactId = generateUUID();\n          const timestamp = now();\n\n          await env.DB.prepare(`\n            INSERT INTO artifacts (id, project_id, agent_id, artifact_type, content, version, created_at)\n            VALUES (?, ?, ?, ?, ?, ?, ?)\n          `).bind(\n            artifactId,\n            body.projectId,\n            `${body.stage}-agent`,\n            'markdown',\n            body.editedArtifact,\n            1,\n            timestamp\n          ).run();\n\n          shouldContinue = true;\n        }\n\n        // Return routing decision\n        return successResponse({\n          projectId: body.projectId,\n          action: body.action,\n          targetStage,\n          shouldContinue,\n          message: body.action === 'approve'\n            ? 'Approved, continuing workflow'\n            : body.action === 'reject'\n              ? `Rejected, re-routing to ${targetStage} stage`\n              : 'Artifact edited, continuing with changes'\n        }, 200, corsHeaders);\n\n      } catch (e: any) {\n        return errorResponse('INTERNAL_ERROR', e.message || 'Failed to resume workflow', 500, null, corsHeaders);\n      }\n    }\n\n    // 8. Handle Parallel Streaming Requests via the new Controller\n    if (isStream && (!target || target === 'graph')) {\n        // Session Persistence: Ensure Project ID exists in D1\n        const projectId = request.headers.get('X-Project-ID');\n        if (projectId) {\n            // We use INSERT OR IGNORE to lazily create the project record if it's the first time we see this ID\n            // Ideally this happens on a dedicated create route, but for robust prototypes, this is safe.\n            ctx.waitUntil(env.DB.prepare(`\n                INSERT OR IGNORE INTO projects (id, name, product_seed, environment)\n                VALUES (?, 'New Project', 'Auto-generated session', 'dev')\n            `).bind(projectId).run().catch(err => console.error(\"Failed to persist session\", err)));\n        }\n\n        return handleStreamRequest(request, env);\n    }\n\n    // 5. Direct Proxy to Agents\n    if (target === 'prd') {\n      return env.PRD_AGENT.fetch(request);\n    }\n    \n    if (target === 'data') {\n      return env.DATA_AGENT.fetch(request);\n    }\n    \n    if (target === 'logic') {\n      return env.LOGIC_AGENT.fetch(request);\n    }\n\n    return new Response(JSON.stringify({\n      status: 'supervisor_active',\n      role: env.AGENT_ROLE || 'supervisor',\n      instruction_preview: SUPERVISOR_PROMPT.substring(0, 50) + \"...\",\n      endpoints: [\n        'GET /api/projects',\n        'GET /api/hydrate/:id',\n        'GET /api/artifacts/content/:key',\n        'POST /api/projects',\n        'POST /api/checkpoints',\n        'POST /api/restore',\n        'POST /api/resume',\n        'POST /api/generate (streaming)'\n      ]\n    }), {\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' }\n    });\n  }\n};\n"],
  "mappings": ";;;;AAEO,IAAM,8BAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuBpC,IAAM,oBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS/B,2BAA2B;AAAA;AAItB,IAAM,oBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsB/B,2BAA2B;AAAA;AAItB,IAAM,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYhC,2BAA2B;;;AC1EtB,IAAMA,qBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS/B,2BAA2B;AAAA;;;ACR7B,eAAsB,gBAAgB,KAAU,WAAoC;AAClF,MAAI,CAAC,IAAI,IAAI;AACT,YAAQ,KAAK,+CAA+C;AAC5D,WAAO;AAAA,EACX;AAEA,MAAI;AAEA,UAAM,UAAU,MAAM,IAAI,GAAG,QAAQ,gDAAgD,EAAE,KAAK,SAAS,EAAE,MAA8B;AACrI,QAAI,CAAC,QAAS,QAAO;AAIrB,UAAM,YAAY,MAAM,IAAI,GAAG,QAAQ,sFAAsF,EAAE,KAAK,SAAS,EAAE,IAAyC;AAExL,QAAI,UAAU,iBAAiB,QAAQ,YAAY;AAAA;AAAA;AAAA;AACnD,QAAI,UAAU,SAAS;AACnB,gBAAU,QAAQ,QAAQ,OAAK;AAI3B,cAAM,iBAAiB,EAAE,QAAQ,SAAS,MAAM,EAAE,QAAQ,UAAU,GAAG,GAAG,IAAI,QAAQ,EAAE;AACxF,mBAAW,IAAI,EAAE,SAAS,YAAY,CAAC,MAAM,cAAc;AAAA;AAAA,MAC/D,CAAC;AAAA,IACL;AAEA,WAAO;AAAA,EACX,SAAS,GAAG;AACR,YAAQ,MAAM,2BAA2B,CAAC;AAC1C,WAAO;AAAA,EACX;AACF;AA/BsB;;;ACKf,SAAS,eAAuB;AACrC,SAAO,OAAO,WAAW;AAC3B;AAFgB;AAOT,SAAS,MAAc;AAC5B,SAAO,KAAK,IAAI;AAClB;AAFgB;AAOT,SAAS,YAAY,MAAuB;AACjD,QAAM,YAAY;AAClB,SAAO,UAAU,KAAK,IAAI;AAC5B;AAHgB;AA4BT,SAAS,cACd,MACA,SACA,SAAiB,KACjB,SACA,cAAsC,CAAC,GAC7B;AACV,QAAM,UAAyB;AAAA,IAC7B,SAAS;AAAA,IACT,OAAO,EAAE,MAAM,SAAS,QAAQ;AAAA,EAClC;AAEA,SAAO,IAAI,SAAS,KAAK,UAAU,OAAO,GAAG;AAAA,IAC3C;AAAA,IACA,SAAS;AAAA,MACP,GAAG;AAAA,MACH,gBAAgB;AAAA,IAClB;AAAA,EACF,CAAC;AACH;AAnBgB;AAwBT,SAAS,gBACd,MACA,SAAiB,KACjB,cAAsC,CAAC,GAC7B;AACV,QAAM,UAA8B;AAAA,IAClC,SAAS;AAAA,IACT;AAAA,EACF;AAEA,SAAO,IAAI,SAAS,KAAK,UAAU,OAAO,GAAG;AAAA,IAC3C;AAAA,IACA,SAAS;AAAA,MACP,GAAG;AAAA,MACH,gBAAgB;AAAA,IAClB;AAAA,EACF,CAAC;AACH;AAjBgB;AAsBhB,eAAsB,iBAAoB,SAA8B;AACtE,MAAI;AACF,WAAO,MAAM,QAAQ,KAAK;AAAA,EAC5B,SAAS,GAAG;AACV,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AACF;AANsB;AAWf,SAAS,oBAAoB,MAAsB;AAExD,SAAO,KAAK,KAAK,EAAE,UAAU,GAAG,GAAG;AACrC;AAHgB;AAQT,SAAS,oBAAoB,MAAsB;AAExD,SAAO,KAAK,KAAK,EAAE,UAAU,GAAG,GAAK;AACvC;AAHgB;AAQT,SAAS,kBAAkB,OAAwB;AACxD,QAAM,mBAAmB,CAAC,QAAQ,OAAO;AACzC,SAAO,iBAAiB,SAAS,KAAK;AACxC;AAHgB;;;ACrGhB,eAAsB,oBAAoB,SAAkB,KAAU;AACpE,QAAM,EAAE,UAAU,SAAS,IAAI,IAAI,gBAAgB;AACnD,QAAM,SAAS,SAAS,UAAU;AAClC,QAAM,UAAU,IAAI,YAAY;AAGhC,MAAI,OAAY,CAAC;AACjB,MAAI;AACA,WAAO,MAAM,QAAQ,KAAK;AAAA,EAC9B,SAAS,GAAG;AACR,YAAQ,KAAK,2DAA2D;AAAA,EAC5E;AAEA,QAAM,YAAY,QAAQ,QAAQ,IAAI,cAAc,KAAK,KAAK;AAG9D,MAAI,kBAAkB;AACtB,MAAI,WAAW;AACX,sBAAkB,MAAM,gBAAgB,KAAK,SAAS;AAAA,EAC1D;AAGA,QAAM,aAAa,CAAC;AACpB,MAAI,IAAI,UAAW,YAAW,KAAK,EAAE,IAAI,OAAO,SAAS,IAAI,UAAU,CAAC;AACxE,MAAI,IAAI,WAAY,YAAW,KAAK,EAAE,IAAI,QAAQ,SAAS,IAAI,WAAW,CAAC;AAC3E,MAAI,IAAI,YAAa,YAAW,KAAK,EAAE,IAAI,SAAS,SAAS,IAAI,YAAY,CAAC;AAG9E,QAAM,iBAAiB,WAAW,IAAI,OAAO,UAAU;AACrD,QAAI;AAEA,YAAM,YAAY;AAAA,QACd,GAAG;AAAA,QACH,UAAU,KAAK,WAAW,MAAM,SAAS;AAAA,MAC7C;AAEA,YAAM,WAAW,IAAI,QAAQ,QAAQ,KAAK;AAAA,QACtC,QAAQ,QAAQ;AAAA,QAChB,SAAS,IAAI,QAAQ,QAAQ,OAAO;AAAA,QACpC,MAAM,KAAK,UAAU,SAAS;AAAA,MAClC,CAAC;AAED,eAAS,QAAQ,IAAI,kBAAkB,MAAM,EAAE;AAC/C,eAAS,QAAQ,IAAI,UAAU,mBAAmB;AAClD,eAAS,QAAQ,IAAI,gBAAgB,kBAAkB;AAEvD,YAAM,WAAW,MAAM,MAAM,QAAQ,MAAM,QAAQ;AACnD,YAAM,SAAS,SAAS,MAAM,UAAU;AAExC,UAAI,CAAC,OAAQ;AAEb,YAAM,UAAU,IAAI,YAAY;AAChC,aAAO,MAAM;AACT,cAAM,EAAE,OAAO,KAAK,IAAI,MAAM,OAAO,KAAK;AAC1C,YAAI,KAAM;AAEV,cAAM,QAAQ,QAAQ,OAAO,OAAO,EAAE,QAAQ,KAAK,CAAC;AACpD,cAAM,QAAQ,MAAM,MAAM,IAAI;AAE9B,mBAAW,QAAQ,OAAO;AACtB,cAAI,KAAK,KAAK,EAAE,WAAW,QAAQ,GAAG;AAClC,gBAAI;AACA,oBAAM,OAAO,KAAK,MAAM,KAAK,UAAU,CAAC,CAAC;AAEzC,kBAAI,SAA8C;AAClD,kBAAI,QAAQ;AAEZ,kBAAI,KAAK,SAAS,SAAS;AACvB,yBAAS;AACT,wBAAQ,KAAK,WAAW;AAAA,cAC5B,WAAW,KAAK,SAAS,UAAU;AAC/B,yBAAS;AACT,wBAAQ,KAAK,WAAW;AAAA,cAC5B,WAAW,KAAK,SAAS,YAAY;AACjC,yBAAS;AACT,wBAAQ,KAAK,WAAW;AAIxB,oBAAI,KAAK,YAAY,kBAAkB,MAAM,EAAE,GAAG;AAC9C,wBAAM,gBAAgB,KAAK;AAE3B,sBAAI,cAAc,cAAc,qBAAqB,MAAM;AAEvD,0BAAM,kBAAkB;AAAA,sBACpB,WAAW,KAAK,IAAI;AAAA,sBACpB,SAAS,MAAM;AAAA,sBACf,OAAO;AAAA,sBACP,QAAQ;AAAA,sBACR,WAAW;AAAA,wBACP,OAAO,MAAM;AAAA,wBACb,UAAU,cAAc;AAAA,wBACxB,SAAS,cAAc,aAAa;AAAA,wBACpC,WAAW,cAAc,OAAO,aAAa;AAAA,sBACjD;AAAA,oBACJ;AAEA,0BAAM,eAAe,SAAS,KAAK,UAAU,eAAe,CAAC;AAAA;AAAA;AAC7D,0BAAM,OAAO,MAAM,QAAQ,OAAO,YAAY,CAAC;AAG/C,4BAAQ,IAAI,6CAA6C,MAAM,EAAE,EAAE;AAGnE;AAAA,kBACJ;AAAA,gBACJ;AAAA,cACJ,WAAW,KAAK,SAAS,SAAS;AAC9B,yBAAS;AACT,wBAAQ,UAAU,KAAK,SAAS,KAAK,OAAO;AAAA,cAChD;AAEA,oBAAM,SAAS;AAAA,gBACX,WAAW,KAAK,IAAI;AAAA,gBACpB,SAAS,MAAM;AAAA,gBACf;AAAA,gBACA;AAAA,cACJ;AAEA,oBAAM,MAAM,SAAS,KAAK,UAAU,MAAM,CAAC;AAAA;AAAA;AAC3C,oBAAM,OAAO,MAAM,QAAQ,OAAO,GAAG,CAAC;AAAA,YAC1C,SAAS,GAAG;AAAA,YAEZ;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,SAAS,GAAG;AACR,YAAM,YAAY;AAAA,QACd,WAAW,KAAK,IAAI;AAAA,QACpB,SAAS,MAAM;AAAA,QACf,OAAO,OAAO,CAAC;AAAA,QACf,QAAQ;AAAA,MACZ;AACA,YAAM,MAAM,SAAS,KAAK,UAAU,SAAS,CAAC;AAAA;AAAA;AAC9C,YAAM,OAAO,MAAM,QAAQ,OAAO,GAAG,CAAC;AAAA,IAC1C;AAAA,EACF,CAAC;AAGD,UAAQ,WAAW,cAAc,EAAE,KAAK,MAAM;AAC1C,WAAO,MAAM;AAAA,EACjB,CAAC;AAED,SAAO,IAAI,SAAS,UAAU;AAAA,IAC5B,SAAS;AAAA,MACP,gBAAgB;AAAA,MAChB,iBAAiB;AAAA,MACjB,cAAc;AAAA,MACd,qBAAqB;AAAA,IACvB;AAAA,EACF,CAAC;AACH;AAxJsB;;;ACyCtB,IAAO,gBAAQ;AAAA,EACb,MAAM,MAAM,SAAkB,KAAU,KAA0C;AAChF,UAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,UAAM,SAAS,QAAQ;AACvB,UAAM,WAAW,QAAQ,QAAQ,IAAI,QAAQ,MAAM;AACnD,UAAM,SAAS,QAAQ,QAAQ,IAAI,gBAAgB,KAAK,IAAI,aAAa,IAAI,OAAO;AAGpF,UAAM,cAAc;AAAA,MAClB,+BAA+B;AAAA,MAC/B,gCAAgC;AAAA,MAChC,gCAAgC;AAAA,IAClC;AAEA,QAAI,WAAW,WAAW;AACxB,aAAO,IAAI,SAAS,MAAM,EAAE,SAAS,YAAY,CAAC;AAAA,IACpD;AAMA,QAAI,WAAW,SAAS,IAAI,aAAa,iBAAiB;AACxD,UAAI;AACF,cAAM,EAAE,QAAQ,IAAI,MAAM,IAAI,GAAG;AAAA,UAC/B;AAAA,QACF,EAAE,IAAI;AACN,eAAO,IAAI,SAAS,KAAK,UAAU,OAAO,GAAG,EAAE,SAAS,EAAE,GAAG,aAAa,gBAAgB,mBAAmB,EAAE,CAAC;AAAA,MAClH,SAAS,GAAG;AACV,eAAO,IAAI,SAAS,KAAK,UAAU,EAAE,OAAO,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,QAAQ,KAAK,SAAS,YAAY,CAAC;AAAA,MACjG;AAAA,IACF;AAIA,QAAI,WAAW,SAAS,IAAI,SAAS,WAAW,eAAe,GAAG;AAChE,YAAM,YAAY,IAAI,SAAS,MAAM,GAAG,EAAE,IAAI;AAC9C,UAAI,CAAC,UAAW,QAAO,IAAI,SAAS,sBAAsB,EAAE,QAAQ,KAAK,SAAS,YAAY,CAAC;AAE/F,UAAI;AAEF,cAAM,CAAC,YAAY,SAAS,cAAc,cAAc,IAAI,MAAM,QAAQ,IAAI;AAAA,UAC5E,IAAI,GAAG,QAAQ,qCAAqC,EAAE,KAAK,SAAS,EAAE,MAAM;AAAA,UAC5E,IAAI,GAAG,QAAQ,wFAAwF,EAAE,KAAK,SAAS,EAAE,IAAI;AAAA,UAC7H,IAAI,GAAG,QAAQ,uEAAuE,EAAE,KAAK,SAAS,EAAE,IAAI;AAAA,UAC5G,IAAI,GAAG,QAAQ,kFAAkF,EAAE,KAAK,SAAS,EAAE,IAAI;AAAA,QACzH,CAAC;AAED,YAAI,CAAC,YAAY;AACf,iBAAO,IAAI,SAAS,qBAAqB,EAAE,QAAQ,KAAK,SAAS,YAAY,CAAC;AAAA,QAChF;AAEA,cAAM,kBAAkB;AAAA,UACtB,SAAS;AAAA,UACT,SAAS;AAAA,YACP,MAAM,QAAQ,WAAW,CAAC;AAAA,YAC1B,WAAW,aAAa,WAAW,CAAC;AAAA,YACpC,aAAa,eAAe,WAAW,CAAC;AAAA,UAC1C;AAAA,QACF;AAEA,eAAO,IAAI,SAAS,KAAK,UAAU,eAAe,GAAG,EAAE,SAAS,EAAE,GAAG,aAAa,gBAAgB,mBAAmB,EAAE,CAAC;AAAA,MAE1H,SAAS,GAAG;AACV,eAAO,IAAI,SAAS,KAAK,UAAU,EAAE,OAAO,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,QAAQ,KAAK,SAAS,YAAY,CAAC;AAAA,MACjG;AAAA,IACF;AAIA,QAAI,WAAW,SAAS,IAAI,SAAS,WAAW,yBAAyB,GAAG;AAExE,YAAM,MAAM,mBAAmB,IAAI,SAAS,QAAQ,2BAA2B,EAAE,CAAC;AAClF,UAAI;AACA,cAAM,SAAS,MAAM,IAAI,QAAQ,IAAI,GAAG;AACxC,YAAI,CAAC,OAAQ,QAAO,IAAI,SAAS,sBAAsB,EAAE,QAAQ,KAAK,SAAS,YAAY,CAAC;AAE5F,cAAM,UAAU,IAAI,QAAQ;AAC5B,eAAO,kBAAkB,OAAO;AAChC,gBAAQ,IAAI,QAAQ,OAAO,QAAQ;AACnC,gBAAQ,IAAI,+BAA+B,GAAG;AAE9C,eAAO,IAAI,SAAS,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,MAChD,SAAS,GAAG;AACR,eAAO,IAAI,SAAS,KAAK,UAAU,EAAE,OAAO,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,QAAQ,KAAK,SAAS,YAAY,CAAC;AAAA,MACnG;AAAA,IACJ;AAMA,QAAI,WAAW,UAAU,IAAI,aAAa,iBAAiB;AACzD,UAAI;AACF,cAAM,OAAO,MAAM,iBAIhB,OAAO;AAGV,YAAI,CAAC,KAAK,eAAe,KAAK,YAAY,KAAK,EAAE,WAAW,GAAG;AAC7D,iBAAO,cAAc,mBAAmB,4BAA4B,KAAK,MAAM,WAAW;AAAA,QAC5F;AAGA,cAAM,YAAY,aAAa;AAC/B,cAAM,YAAY,IAAI;AACtB,cAAM,cAAc,KAAK,OAAO,oBAAoB,KAAK,IAAI,IAAI;AACjE,cAAM,cAAc,oBAAoB,KAAK,WAAW;AACxD,cAAM,cAAc,KAAK,eAAe;AAGxC,cAAM,SAAS,MAAM,IAAI,GAAG,QAAQ;AAAA;AAAA;AAAA,SAGnC,EAAE,KAAK,WAAW,aAAa,aAAa,aAAa,WAAW,SAAS,EAAE,IAAI;AAEpF,YAAI,CAAC,OAAO,SAAS;AACnB,iBAAO,cAAc,kBAAkB,4BAA4B,KAAK,OAAO,OAAO,WAAW;AAAA,QACnG;AAGA,eAAO,gBAAgB;AAAA,UACrB;AAAA,UACA,MAAM;AAAA,UACN;AAAA,UACA;AAAA,UACA,WAAW;AAAA,UACX,WAAW;AAAA,QACb,GAAG,KAAK,WAAW;AAAA,MAErB,SAAS,GAAQ;AACf,eAAO,cAAc,kBAAkB,EAAE,WAAW,4BAA4B,KAAK,MAAM,WAAW;AAAA,MACxG;AAAA,IACF;AAIA,QAAI,WAAW,UAAU,IAAI,aAAa,oBAAoB;AAC5D,UAAI;AACF,cAAM,OAAO,MAAM,iBAMhB,OAAO;AAGV,YAAI,CAAC,KAAK,aAAa,CAAC,YAAY,KAAK,SAAS,GAAG;AACnD,iBAAO,cAAc,mBAAmB,gCAAgC,KAAK,MAAM,WAAW;AAAA,QAChG;AAEA,YAAI,CAAC,KAAK,OAAO;AACf,iBAAO,cAAc,mBAAmB,qBAAqB,KAAK,MAAM,WAAW;AAAA,QACrF;AAEA,cAAM,eAAe,aAAa;AAClC,cAAM,YAAY,IAAI;AACtB,cAAM,YAAY,KAAK,UAAU,KAAK,aAAa;AAGnD,cAAM,SAAS,MAAM,IAAI,GAAG,QAAQ;AAAA;AAAA;AAAA,SAGnC,EAAE;AAAA,UACD;AAAA,UACA,KAAK;AAAA,UACL,KAAK;AAAA,UACL;AAAA,UACA,KAAK,WAAW;AAAA,UAChB,KAAK,gBAAgB,IAAI;AAAA,UACzB;AAAA,QACF,EAAE,IAAI;AAEN,YAAI,CAAC,OAAO,SAAS;AACnB,iBAAO,cAAc,kBAAkB,6BAA6B,KAAK,OAAO,OAAO,WAAW;AAAA,QACpG;AAEA,eAAO,gBAAgB;AAAA,UACrB;AAAA,UACA,WAAW,KAAK;AAAA,UAChB,OAAO,KAAK;AAAA,UACZ,WAAW;AAAA,QACb,GAAG,KAAK,WAAW;AAAA,MAErB,SAAS,GAAQ;AACf,eAAO,cAAc,kBAAkB,EAAE,WAAW,6BAA6B,KAAK,MAAM,WAAW;AAAA,MACzG;AAAA,IACF;AAIA,QAAI,WAAW,UAAU,IAAI,aAAa,gBAAgB;AACxD,UAAI;AACF,cAAM,OAAO,MAAM,iBAGhB,OAAO;AAGV,YAAI,CAAC,KAAK,aAAa,CAAC,YAAY,KAAK,SAAS,GAAG;AACnD,iBAAO,cAAc,mBAAmB,gCAAgC,KAAK,MAAM,WAAW;AAAA,QAChG;AAEA,YAAI,CAAC,KAAK,gBAAgB,CAAC,YAAY,KAAK,YAAY,GAAG;AACzD,iBAAO,cAAc,mBAAmB,mCAAmC,KAAK,MAAM,WAAW;AAAA,QACnG;AAGA,cAAM,aAAa,MAAM,IAAI,GAAG,QAAQ;AAAA;AAAA,SAEvC,EAAE,KAAK,KAAK,cAAc,KAAK,SAAS,EAAE,MAAM;AAEjD,YAAI,CAAC,YAAY;AACf,iBAAO,cAAc,aAAa,wBAAwB,KAAK,MAAM,WAAW;AAAA,QAClF;AAGA,YAAI;AACJ,YAAI;AACF,0BAAgB,KAAK,MAAM,WAAW,cAAwB;AAAA,QAChE,SAAS,GAAG;AACV,iBAAO,cAAc,kBAAkB,2BAA2B,KAAK,MAAM,WAAW;AAAA,QAC1F;AAGA,cAAM,IAAI,GAAG,QAAQ;AAAA;AAAA;AAAA,SAGpB,EAAE,KAAK,KAAK,WAAW,WAAW,UAAU,EAAE,IAAI;AAGnD,eAAO,gBAAgB;AAAA,UACrB,WAAW,KAAK;AAAA,UAChB,cAAc,KAAK;AAAA,UACnB,OAAO,WAAW;AAAA,UAClB;AAAA,UACA,YAAY,IAAI;AAAA,QAClB,GAAG,KAAK,WAAW;AAAA,MAErB,SAAS,GAAQ;AACf,eAAO,cAAc,kBAAkB,EAAE,WAAW,gCAAgC,KAAK,MAAM,WAAW;AAAA,MAC5G;AAAA,IACF;AAIA,QAAI,WAAW,UAAU,IAAI,aAAa,eAAe;AACvD,UAAI;AACF,cAAM,OAAO,MAAM,iBAMhB,OAAO;AAGV,YAAI,CAAC,KAAK,aAAa,CAAC,YAAY,KAAK,SAAS,GAAG;AACnD,iBAAO,cAAc,mBAAmB,gCAAgC,KAAK,MAAM,WAAW;AAAA,QAChG;AAEA,YAAI,CAAC,KAAK,OAAO;AACf,iBAAO,cAAc,mBAAmB,qBAAqB,KAAK,MAAM,WAAW;AAAA,QACrF;AAEA,YAAI,CAAC,CAAC,WAAW,UAAU,MAAM,EAAE,SAAS,KAAK,MAAM,GAAG;AACxD,iBAAO,cAAc,mBAAmB,2CAA2C,KAAK,MAAM,WAAW;AAAA,QAC3G;AAGA,YAAI,cAAc,KAAK;AACvB,YAAI,iBAAiB;AAErB,YAAI,KAAK,WAAW,WAAW;AAE7B,2BAAiB;AAAA,QACnB,WAAW,KAAK,WAAW,UAAU;AAInC,gBAAM,WAAW,KAAK,YAAY;AAGlC,cAAI,SAAS,YAAY,EAAE,SAAS,aAAa,KAAK,SAAS,YAAY,EAAE,SAAS,KAAK,GAAG;AAC5F,0BAAc;AAAA,UAChB,WAAW,SAAS,YAAY,EAAE,SAAS,QAAQ,KAAK,SAAS,YAAY,EAAE,SAAS,IAAI,GAAG;AAC7F,0BAAc;AAAA,UAChB,OAAO;AAEL,0BAAc,KAAK;AAAA,UACrB;AAEA,2BAAiB;AAAA,QACnB,WAAW,KAAK,WAAW,QAAQ;AAEjC,cAAI,CAAC,KAAK,gBAAgB;AACxB,mBAAO,cAAc,mBAAmB,+CAA+C,KAAK,MAAM,WAAW;AAAA,UAC/G;AAGA,gBAAM,aAAa,aAAa;AAChC,gBAAM,YAAY,IAAI;AAEtB,gBAAM,IAAI,GAAG,QAAQ;AAAA;AAAA;AAAA,WAGpB,EAAE;AAAA,YACD;AAAA,YACA,KAAK;AAAA,YACL,GAAG,KAAK,KAAK;AAAA,YACb;AAAA,YACA,KAAK;AAAA,YACL;AAAA,YACA;AAAA,UACF,EAAE,IAAI;AAEN,2BAAiB;AAAA,QACnB;AAGA,eAAO,gBAAgB;AAAA,UACrB,WAAW,KAAK;AAAA,UAChB,QAAQ,KAAK;AAAA,UACb;AAAA,UACA;AAAA,UACA,SAAS,KAAK,WAAW,YACrB,kCACA,KAAK,WAAW,WACd,2BAA2B,WAAW,WACtC;AAAA,QACR,GAAG,KAAK,WAAW;AAAA,MAErB,SAAS,GAAQ;AACf,eAAO,cAAc,kBAAkB,EAAE,WAAW,6BAA6B,KAAK,MAAM,WAAW;AAAA,MACzG;AAAA,IACF;AAGA,QAAI,aAAa,CAAC,UAAU,WAAW,UAAU;AAE7C,YAAM,YAAY,QAAQ,QAAQ,IAAI,cAAc;AACpD,UAAI,WAAW;AAGX,YAAI,UAAU,IAAI,GAAG,QAAQ;AAAA;AAAA;AAAA,aAG5B,EAAE,KAAK,SAAS,EAAE,IAAI,EAAE,MAAM,SAAO,QAAQ,MAAM,6BAA6B,GAAG,CAAC,CAAC;AAAA,MAC1F;AAEA,aAAO,oBAAoB,SAAS,GAAG;AAAA,IAC3C;AAGA,QAAI,WAAW,OAAO;AACpB,aAAO,IAAI,UAAU,MAAM,OAAO;AAAA,IACpC;AAEA,QAAI,WAAW,QAAQ;AACrB,aAAO,IAAI,WAAW,MAAM,OAAO;AAAA,IACrC;AAEA,QAAI,WAAW,SAAS;AACtB,aAAO,IAAI,YAAY,MAAM,OAAO;AAAA,IACtC;AAEA,WAAO,IAAI,SAAS,KAAK,UAAU;AAAA,MACjC,QAAQ;AAAA,MACR,MAAM,IAAI,cAAc;AAAA,MACxB,qBAAqBC,mBAAkB,UAAU,GAAG,EAAE,IAAI;AAAA,MAC1D,WAAW;AAAA,QACT;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC,GAAG;AAAA,MACF,SAAS,EAAE,GAAG,aAAa,gBAAgB,mBAAmB;AAAA,IAChE,CAAC;AAAA,EACH;AACF;",
  "names": ["SUPERVISOR_PROMPT", "SUPERVISOR_PROMPT"]
}
